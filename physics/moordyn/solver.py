import moordyn
import numpy as np
import os
import sys


class MoorDynWrapper:
    def __init__(self, params, seastate, dt):
        # 1. 预先初始化 system 为 None
        self.system = None

        self.p = params
        self.dt = float(dt)
        self.fairlead_points = None
        self.anchor_points = None

        # --- 2. 自动生成与项目参数一致的输入文件 ---
        current_dir = os.path.dirname(os.path.abspath(__file__))
        self.input_file = os.path.join(current_dir, "text_MoorDyn.dat")

        print(f"[MoorDyn-Wrapper] Generating input file based on LabFAST params: {self.input_file}")
        self._load_custom_points()
        self._generate_project_input_file(self.input_file)

        # --- 3. 创建系统 ---
        # 尝试清理旧实例
        try:
            moordyn.Close(None)
        except:
            pass

        try:
            self.system = moordyn.Create(self.input_file)
        except Exception as e:
            print(f"[MoorDyn-Wrapper] Exception calling Create(): {e}")

        if not self.system:
            print("[MoorDyn-Wrapper] FATAL: moordyn.Create() failed.")
            raise RuntimeError("MoorDyn system creation failed. Check input file format.")

        # --- 4. 识别耦合点 ID ---
        # 逻辑：Line i -> Anchor = 2*i+1, Fairlead = 2*i+2 (偶数)
        self.n_lines = int(self.fairlead_points.shape[0])
        self.fairlead_ids = [(i * 2 + 2) for i in range(self.n_lines)]

        # --- 5. 计算完美的初始位置 (用于 Init) ---
        x_init = []
        for i in range(self.n_lines):
            fx, fy, fz = self.fairlead_points[i]
            x_init.extend([fx, fy, fz])

        # 初始速度 (全0)
        xd_init = [0.0] * len(x_init)

        # --- 6. 初始化求解器 ---
        print(f"[MoorDyn-Wrapper] Initializing system...")
        try:
            # 必须传入 float 列表
            moordyn.Init(self.system, x_init, xd_init)
            print("[MoorDyn-Wrapper] Init() completed successfully.")
        except Exception as e:
            print(f"[MoorDyn-Wrapper] CRASH during Init(): {e}")
            if self.system:
                moordyn.Close(self.system)
                self.system = None
            raise

    def _generate_project_input_file(self, filename):
        """
        核心函数：将 LabFAST 的 SystemParams 转换为 MoorDyn V2 输入文件
        修正：LINE TYPES 增加 EI 列，满足 10 列要求
        """
        p = self.p
        try:
            with open(filename, 'w') as f:
                f.write("MoorDyn V2 Input File - Auto Generated by LabFAST\n")
                f.write("False         Echo      - echo the input file data (flag)\n")

                # --- A. LINE TYPES (修正处: 增加 EI 列) ---
                f.write("---------------------- LINE TYPES -----------------------------------\n")
                # 10 Columns: Name, Diam, Mass, EA, BA, EI, Cd, Ca, CdAx, CaAx
                f.write("Name      Diam     MassDen   EA        BA/-zeta  EI        Cd      Ca      CdAx    CaAx\n")
                f.write("(-)       (m)      (kg/m)    (N)       (N-s/-)   (N-m^2)   (-)     (-)     (-)     (-)\n")

                diam = 0.15
                mass = float(p.Moor_LineMass)
                ea = float(p.Moor_LineEA)
                cd = float(p.Moor_DragCoeff)

                # EI = 0.0 (Chain)
                # Ca = 0.8 (Added mass coeff)
                # CdAx = 0.4 (Axial drag)
                # CaAx = 0.0 (Axial added mass)
                f.write(
                    f"chain    {diam:.4f}   {mass:.4f}   {ea:.4e}  -1.0      0.0       {cd:.2f}    0.8     0.4     0.0\n")

                # --- B. POINTS ---
                f.write("---------------------- POINTS ---------------------------------------\n")
                # 12 Columns standard format
                f.write(
                    "ID    Type      X          Y          Z          M       V       FX      FY      FZ      CdA     Ca\n")
                f.write(
                    "(-)   (-)       (m)        (m)        (m)        (kg)    (m^3)   (N)     (N)     (N)     (m^2)   (-)\n")

                n = int(self.fairlead_points.shape[0])
                pid = 1
                for i in range(n):
                    # 1. Anchor (Fixed)
                    ax, ay, az = self.anchor_points[i]
                    f.write(
                        f"{pid:<5} Fixed     {ax:<10.4f} {ay:<10.4f} {az:<10.4f} 0.0     0.0     0.0     0.0     0.0     0.0     0.0\n")
                    pid += 1

                    # 2. Fairlead (Coupled)
                    fx, fy, fz = self.fairlead_points[i]
                    f.write(
                        f"{pid:<5} Coupled   {fx:<10.4f} {fy:<10.4f} {fz:<10.4f} 0.0     0.0     0.0     0.0     0.0     0.0     0.0\n")
                    pid += 1

                # --- C. LINES ---
                f.write("---------------------- LINES ----------------------------------------\n")
                f.write("ID    LineType  AttachA  AttachB  UnstrLen  NumSegs  Outputs\n")
                f.write("(-)   (-)       (-)      (-)      (m)       (-)      (-)\n")

                L = float(p.Moor_LineLength)
                N_segs = 40

                for i in range(n):
                    lid = i + 1
                    aid = 2 * i + 1  # Anchor
                    fid = 2 * i + 2  # Fairlead
                    f.write(f"{lid:<5} chain     {aid:<8} {fid:<8} {L:<9.4f} {N_segs:<8} p\n")

                # --- D. SOLVER OPTIONS ---
                f.write("---------------------- SOLVER OPTIONS -------------------------------\n")
                f.write(f"0.001     dtM          - time step (s)\n")
                f.write(f"{float(p.Gravity):.2f}      g            - gravity (m/s^2)\n")
                f.write(f"{float(p.WaterDensity):.1f}   rho          - water density (kg/m^3)\n")

                f.write("3.0e6     kbot         - bottom stiffness (Pa/m)\n")
                f.write("3.0e5     cbot         - bottom damping (Pa-s/m)\n")
                # Value Option format
                f.write("0         WaveKin      - No internal waves (handled by LabFAST)\n")

                # --- E. OUTPUTS ---
                f.write("------------------------ OUTPUTS ------------------------------------\n")
                for i in range(n):
                    lid = i + 1
                    f.write(f"FairTen{lid}\n")
                    f.write(f"AnchTen{lid}\n")
                f.write("END\n")

        except IOError as e:
            print(f"[MoorDyn-Gen] Error writing file: {e}")
            raise

    def update(self, state, t):
        """
        state: 12-vector [x, y, z, roll, pitch, yaw, vx, vy, vz, vroll, vpitch, vyaw]
        """
        # 1. 提取数据并转 float
        surge, sway, heave = float(state[0]), float(state[1]), float(state[2])
        roll, pitch, yaw = float(state[3]), float(state[4]), float(state[5])

        v_plat = np.array([state[6], state[7], state[8]], dtype=float)
        omega_plat = np.array([state[9], state[10], state[11]], dtype=float)

        # 2. 旋转矩阵
        R = np.eye(3)
        R[0, 1] = -yaw;
        R[0, 2] = pitch
        R[1, 0] = yaw;
        R[1, 2] = -roll
        R[2, 0] = -pitch;
        R[2, 1] = roll

        r_plat = np.array([surge, sway, heave], dtype=float)

        x_input = []
        xd_input = []

        # 3. 计算所有导缆孔当前状态
        for i in range(self.n_lines):
            fl_local = np.array(self.fairlead_points[i], dtype=float)

            # 全局位置与速度
            fl_global = r_plat + R @ fl_local
            arm_vec = R @ fl_local
            fl_vel = v_plat + np.cross(omega_plat, arm_vec)

            x_input.extend(fl_global.tolist())
            xd_input.extend(fl_vel.tolist())

        # 4. 步进
        try:
            moordyn.Step(self.system, x_input, xd_input, float(t), self.dt)

            # 5. 力回收
            F_total_force = np.zeros(3)
            F_total_moment = np.zeros(3)

            for i, fl_id in enumerate(self.fairlead_ids):
                point = moordyn.GetPoint(self.system, fl_id)
                f_vec = np.array(moordyn.GetPointForce(point))

                if np.isnan(f_vec).any():
                    print(f"[MoorDyn-Wrapper] WARNING: NaN force at t={t:.2f}")
                    return np.zeros(14)

                F_total_force += f_vec

                # 力矩计算
                fl_local_base = np.array(self.fairlead_points[i], dtype=float)
                r_arm_global = R @ fl_local_base
                F_total_moment += np.cross(r_arm_global, f_vec)

            F_ext = np.zeros(14)
            F_ext[0:3] = F_total_force
            F_ext[3:6] = F_total_moment
            return F_ext

        except Exception as e:
            print(f"[MoorDyn-Wrapper] Error in Step at t={t:.4f}: {e}")
            return np.zeros(14)

    def close(self):
        if self.system:
            moordyn.Close(self.system)
            self.system = None

    def __del__(self):
        self.close()

    def _load_custom_points(self):
        fairlead_points = getattr(self.p, "Moor_FairleadPoints", None)
        anchor_points = getattr(self.p, "Moor_AnchorPoints", None)
        if fairlead_points is None or anchor_points is None:
            raise ValueError("Moor_FairleadPoints and Moor_AnchorPoints must both be provided.")

        fairlead_points = np.asarray(fairlead_points, dtype=float)
        anchor_points = np.asarray(anchor_points, dtype=float)

        if fairlead_points.ndim != 2 or fairlead_points.shape[1] != 3:
            raise ValueError("Moor_FairleadPoints must be an N x 3 array-like.")
        if anchor_points.ndim != 2 or anchor_points.shape[1] != 3:
            raise ValueError("Moor_AnchorPoints must be an N x 3 array-like.")
        if fairlead_points.shape[0] != anchor_points.shape[0]:
            raise ValueError("Moor_FairleadPoints and Moor_AnchorPoints must have the same length.")
        if fairlead_points.shape[0] == 0:
            raise ValueError("Moor_FairleadPoints and Moor_AnchorPoints cannot be empty.")

        self.fairlead_points = fairlead_points
        self.anchor_points = anchor_points
